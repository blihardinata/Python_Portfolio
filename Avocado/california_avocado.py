# -*- coding: utf-8 -*-
"""California_Avocado.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hojB-dj82mT245rndeCMl43-BDBPqjrl

# Program Initialization Section
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('https://raw.githubusercontent.com/blihardinata/Python_Portfolio/main/Avocado/avocado-updated-2020.csv')
df.head()

"""Datasets: https://www.kaggle.com/timmate/avocado-prices-2020

- Date - The date of the observation
- AveragePrice - the average price of a single avocado
- type - conventional or organic
- year - the year
- Region - the city or region of the observation
- Total Volume - Total number of avocados sold
- 4046(Small Haas) - Total number of avocados with PLU 4046 sold
- 4225(Large Haas) - Total number of avocados with PLU 4225 sold
- 4770(Extra Large Haas) - Total number of avocados with PLU 4770 sold

PLU = Price Look-Up Code that identifies produce items based upon commodity, variety, and size groups

# Data Investigation, Cleaning and Transformation
"""

df = df.rename(columns={'4046': 'Small_Haas',
                        '4225': 'Large_Haas',
                        '4770': 'xtra_Large_Haas'})
df.head()

df.describe()

df.shape

df.info()

#checking null columns
df.isnull().sum()

#Change the date into "date" 
df['date'] = pd.to_datetime(df['date'], infer_datetime_format=True)

df.info()

"""# Correlation Coefficients"""

#Make a copy to type of avocado
df['factor_type'] = df['type'].copy()

#categorize avodcado into numeric
df['factor_type'] = pd.factorize(df.factor_type)[0]
df.head()

#customize cmap color
plt.figure(figsize=(10,8))

#np.triu is to eliminate the top half of the triangle 
mask = np.triu(np.ones_like(df.corr(), dtype=np.bool))
heatmap = sns.heatmap(df.corr(), mask=mask, annot=True, cmap='YlGn', linewidths=.5)
heatmap.set_title('Correlation Heatmap', fontdict={'fontsize':16}, pad=12)

"""# Conventional Avocado
- California
- New York
- Total US
"""

dfconventional = df[df["type"]=="conventional"]
dfconventional.head()

df.columns

conventional = dfconventional.groupby('date')['average_price'].mean()
conventional = pd.DataFrame(conventional)
conventional.tail()

#looking at the moving average
#window = 12 -> moving average at monthly level 
#window = 365 -> moving average at daily level
m_avg = conventional.rolling(window=12).mean()
print(m_avg)

#Plot rolling statistics
plt.figure(figsize = (20,10))
original = plt.plot(conventional,  color = 'DarkOliveGreen', label = 'Average Price')
mov_avg = plt.plot(m_avg, color = 'brown', label = 'Moving Average')
plt.legend(loc = 'best')
plt.xticks(rotation = 90)
plt.title('Moving Average VS Original')
plt.grid()
plt.show()

"""## Conventional Avocado: California"""

conventional_cali = dfconventional.loc[dfconventional.geography == "California"]
conventional_cali.head()

df_conv_cali = pd.DataFrame(conventional_cali.groupby("date")["average_price"].mean())
df_conv_cali

#looking at the moving average
#window = 12 -> moving average at monthly level 
#window = 365 -> moving average at daily level
conv_cali = df_conv_cali.rolling(window=12).mean()

#Plot rolling statistics
plt.figure(figsize = (20,10))
original = plt.plot(df_conv_cali,  color = 'DarkOliveGreen', label = 'Average Price')
mov_avg = plt.plot(conv_cali, color = 'brown', label = 'Moving Average')
plt.legend(loc = 'best')
plt.xticks(rotation = 90)
plt.title('California: Moving Average VS Original Price for Conventional Avocado')
plt.grid()
plt.show()

"""### Check Seasonality/Trend

Resources: https://machinelearningmastery.com/decompose-time-series-data-trend-seasonality/
- Time series decomposition involves thinking of a series as a combination of level, trend, seasonality, and noise components.
- Decomposition provides a useful abstract model for thinking about time series generally and for better understanding problems during time series analysis and forecasting.
"""

import statsmodels.api as sm
from statsmodels.tsa.seasonal import seasonal_decompose

"""Observed = Actual Data

Trend = identified by trendlines or price action that highlight when the price is making higher swing highs and higher swing lows for an uptrend, or lower swing lows and lower swing highs for a downtrend

Seasonality = a characteristic of a time series in which the data experiences regular and predictable changes that recur every calendar year

Residual = error / the difference between observed and forecast
"""

#An additive model is linear where changes over time are consistently made by the same amount.
#y(t) = Level + Trend + Seasonality + Noise
result = seasonal_decompose(df_conv_cali, model= 'additive', freq=52)
result.plot()
plt.show()

#A multiplicative model is nonlinear, such as quadratic or exponential. Changes increase or decrease over time
#y(t) = Level * Trend * Seasonality * Noise
result = seasonal_decompose(df_conv_cali, model= 'multiplicative', freq=52)
result.plot()
plt.show()

"""Both additive and multiplicative model show that:
- Data has trend and seasonality
- Data has an upward trend as shown under trend graph
- Data has a yearly seasonal pattern as shown that average price increases during 2nd half of the year. 
- Data is not a linear trend

### Facebook Forecasting

- https://www.digitalocean.com/community/tutorials/a-guide-to-time-series-forecasting-with-prophet-in-python-3
- https://facebook.github.io/prophet/docs/quick_start.html
"""

from fbprophet import  Prophet

df_conv_cali_prop = df_conv_cali.copy()
df_conv_cali_prop = df_conv_cali_prop.reset_index()
df_conv_cali_prop.head()

#columns must be changed to ds (date) and y (target variable)
df_conv_cali_prop.columns = ['ds', 'y']

#0.95 = 95% confidence interval
m = Prophet(interval_width=0.95)
m.fit(df_conv_cali_prop)

#periods = 52 -> 52 datestamps later
#freq = 'W' -> weekly

future = m.make_future_dataframe(periods = 52, freq='W') 
future.tail()

#build a forecast model
#yhat = predicted value

forecast = m.predict(future)
forecast.tail()

#the black dots are the actual value
#blue line = the forecasted value
#uncertainty level = shaded-blue area
m.plot(forecast, xlabel= 'date', ylabel='Average Price')
plt.title('California Conventional Avocado Price in 52 Weeks Span', y = 1.05)

fig2 = m.plot_components(forecast)

"""The trend graph shows that the average price of conventional avocado continues to drop starting in the middle of 2019. The trend forecasts that the price will continue to drop in 2 years from now. COVID-19 pandemic definitely affects the consumption of Avocado fruits.

### Creating the final dataset in Excel
"""

dfcon_cali = forecast[['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper']]
dfcon_cali = dfcon_cali.set_index('ds')
dfcon_cali.head()

conventional_cali_final = conventional_cali.copy()

conventional_cali_final = conventional_cali_final.set_index('date')
conventional_cali_final.head()

dfcon_cali = pd.concat([conventional_cali_final, dfcon_cali], axis = 1, join= 'outer')
dfcon_cali = dfcon_cali.reset_index()
dfcon_cali = dfcon_cali.rename(columns={'index': 'date'})
dfcon_cali.head()

dfcon_cali.to_excel(r'/content/drive/MyDrive/MSBA_Colab_2020/ML_Algorithms/dfcon_cali.xlsx', index=False, header=True)

"""# Organic Avocado"""

dforganic = df[df["type"]=="organic"]
dforganic.head()

organic = dforganic.groupby('date')['average_price'].mean()
organic = pd.DataFrame(organic)
organic.tail()

#looking at the moving average
#window = 12 -> moving average at monthly level 
#window = 365 -> moving average at daily level
organic_m_avg = organic.rolling(window=12).mean()
print(organic_m_avg)

#Plot rolling statistics
plt.figure(figsize = (20,10))
org_original = plt.plot(organic,  color = 'DarkOliveGreen', label = 'Average Price')
org_mov_avg = plt.plot(organic_m_avg, color = 'brown', label = 'Moving Average')
plt.legend(loc = 'best')
plt.xticks(rotation = 90)
plt.title('Moving Average VS Original')
plt.grid()
plt.show()

"""## Organic Avocado: California"""

organic_cali = dforganic.loc[dforganic.geography == "California"]
organic_cali.head()

df_org_cali = pd.DataFrame(organic_cali.groupby("date")["average_price"].mean())
df_org_cali

#looking at the moving average
#window = 12 -> moving average at monthly level 
#window = 365 -> moving average at daily level
org_cali = df_org_cali.rolling(window=12).mean()

#Plot rolling statistics
plt.figure(figsize = (20,10))
original = plt.plot(df_org_cali,  color = 'DarkOliveGreen', label = 'Average Price')
mov_avg = plt.plot(org_cali, color = 'brown', label = 'Moving Average')
plt.legend(loc = 'best')
plt.xticks(rotation = 90)
plt.title('California: Moving Average VS Original Price for Conventional Avocado')
plt.grid()
plt.show()

"""### Check Seasonality/Trend

Resources: https://machinelearningmastery.com/decompose-time-series-data-trend-seasonality/
- Time series decomposition involves thinking of a series as a combination of level, trend, seasonality, and noise components.
- Decomposition provides a useful abstract model for thinking about time series generally and for better understanding problems during time series analysis and forecasting.
"""

import statsmodels.api as sm
from statsmodels.tsa.seasonal import seasonal_decompose

"""Observed = Actual Data

Trend = identified by trendlines or price action that highlight when the price is making higher swing highs and higher swing lows for an uptrend, or lower swing lows and lower swing highs for a downtrend

Seasonality = a characteristic of a time series in which the data experiences regular and predictable changes that recur every calendar year

Residual = error / the difference between observed and forecast
"""

#An additive model is linear where changes over time are consistently made by the same amount.
#y(t) = Level + Trend + Seasonality + Noise
result = seasonal_decompose(df_org_cali, model= 'additive', freq=52)
result.plot()
plt.show()

#A multiplicative model is nonlinear, such as quadratic or exponential. Changes increase or decrease over time
#y(t) = Level * Trend * Seasonality * Noise
result = seasonal_decompose(df_org_cali, model= 'multiplicative', freq=52)
result.plot()
plt.show()

"""Both additive and multiplicative model show that:
- Data has trend and seasonality
- Data has an upward trend as shown under trend graph
- Data has a yearly seasonal pattern as shown that average price increases during 2nd half of the year. 
- Data is not a linear trend

### Facebook Forecasting

- https://www.digitalocean.com/community/tutorials/a-guide-to-time-series-forecasting-with-prophet-in-python-3
- https://facebook.github.io/prophet/docs/quick_start.html
"""

from fbprophet import  Prophet

df_org_cali_prop = df_org_cali.copy()
df_org_cali_prop = df_org_cali_prop.reset_index()
df_org_cali_prop.head()

#columns must be changed to ds (date) and y (target variable)
df_org_cali_prop.columns = ['ds', 'y']

#0.95 = 95% confidence interval
m_organic = Prophet(interval_width=0.95)
m_organic.fit(df_org_cali_prop)

#periods = 52 -> 52 datestamps later
#freq = 'W' -> weekly

future = m_organic.make_future_dataframe(periods = 52, freq='W') 
future.tail()

#build a forecast model
#yhat = predicted value

forecast_org = m_organic.predict(future)
forecast_org.tail()

#the black dots are the actual value
#blue line = the forecasted value
#uncertainty level = shaded-blue area
m_organic.plot(forecast_org, xlabel= 'date', ylabel='Average Price')
plt.title('California Organic Avocado Price in 52 Weeks Span', y = 1.05)

fig2 = m_organic.plot_components(forecast)

"""The trend graph shows that the average price of organic avocado continues to drop starting in the middle of 2019. The trend forecasts that the price will continue to drop in 2 years from now. COVID-19 pandemic definitely affects the consumption of Avocado fruits.

### Creating the final dataset in Excel
"""

dforg_cali = forecast_org[['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper']]
dforg_cali = dforg_cali.set_index('ds')
dforg_cali.head()

organic_cali_final = organic_cali.copy()

organic_cali_final = organic_cali_final.set_index('date')
organic_cali_final.head()

dforg_cali = pd.concat([organic_cali_final, dforg_cali], axis = 1, join= 'outer')
dforg_cali = dforg_cali.reset_index()
dforg_cali = dforg_cali.rename(columns={'index': 'date'})
dforg_cali.head()

dforg_cali.tail()

dforg_cali.to_excel(r'/content/drive/MyDrive/MSBA_Colab_2020/ML_Algorithms/dforganic.xlsx', index=False, header=True)